(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.ReduxLoop = {}));
}(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var concat = Array.prototype.concat;
  var flatten = function flatten(array) {
    return concat.apply([], array);
  };
  var throwInvariant = function throwInvariant(condition, message) {
    if (!condition) {
      throw Error(message);
    }
  };
  var isPromiseLike = function isPromiseLike(obj) {
    return !!obj && _typeof(obj) === 'object' && typeof obj.then === 'function';
  };

  var _Object$freeze4;
  var isCmdSymbol = Symbol('isCmd');
  var dispatchSymbol = Symbol('dispatch');
  var getStateSymbol = Symbol('getState');
  var cmdTypes = {
    RUN: 'RUN',
    ACTION: 'ACTION',
    SET_TIMEOUT: 'SET_TIMEOUT',
    SET_INTERVAL: 'SET_INTERVAL',
    LIST: 'LIST',
    MAP: 'MAP',
    NONE: 'NONE'
  };
  function isCmd(object) {
    return object ? !!object[isCmdSymbol] : false;
  }

  function getMappedCmdArgs() {
    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var dispatch = arguments.length > 1 ? arguments[1] : undefined;
    var getState = arguments.length > 2 ? arguments[2] : undefined;
    return args.map(function (arg) {
      if (arg === dispatchSymbol) {
        return dispatch;
      } else if (arg === getStateSymbol) {
        return getState;
      } else {
        return arg;
      }
    });
  }

  function handleRunCmd(cmd, context) {
    var dispatch = context.dispatch,
        getState = context.getState,
        loopConfig = context.loopConfig;

    var onSuccess = cmd.successActionCreator || function () {};

    var onFail;

    if (cmd.failActionCreator) {
      onFail = function onFail(error) {
        if (!loopConfig.DONT_LOG_ERRORS_ON_HANDLED_FAILURES) {
          console.error(error);
        }

        return cmd.failActionCreator(error);
      };
    } else {
      onFail = console.error;
    }

    try {
      var result = cmd.func.apply( // Pass undefined so that 'this' will not point to our 'cmd' object.
      undefined, getMappedCmdArgs(cmd.args, dispatch, getState));

      if (isPromiseLike(result) && !cmd.forceSync) {
        return result.then(onSuccess, onFail).then(function (action) {
          return action ? [action] : [];
        });
      }

      var resultAction = onSuccess(result);
      return resultAction ? Promise.resolve([resultAction]) : null;
    } catch (err) {
      if (!cmd.failActionCreator) {
        console.error(err);
        throw err; //don't swallow errors if they are not handling them
      }

      var _resultAction = onFail(err);

      return _resultAction ? Promise.resolve([_resultAction]) : null;
    }
  }

  function handleParallelList(_ref, context) {
    var cmds = _ref.cmds,
        _ref$batch = _ref.batch,
        batch = _ref$batch === void 0 ? false : _ref$batch;
    var promises = cmds.map(function (nestedCmd) {
      var possiblePromise = executeCmdInternal(nestedCmd, context);

      if (!possiblePromise || batch) {
        return possiblePromise;
      }

      return possiblePromise.then(function (result) {
        return Promise.all(result.map(function (a) {
          return context.wrappedDispatch(a);
        }));
      });
    }).filter(function (x) {
      return x;
    });

    if (promises.length === 0) {
      return null;
    }

    return Promise.all(promises).then(flatten).then(function (actions) {
      return batch ? actions : [];
    });
  }

  function handleSequenceList(_ref2, context) {
    var cmds = _ref2.cmds,
        _ref2$batch = _ref2.batch,
        batch = _ref2$batch === void 0 ? false : _ref2$batch;
    var firstCmd = cmds.length ? cmds[0] : null;

    if (!firstCmd) {
      return null;
    }

    var result = new Promise(function (resolve) {
      var firstPromise = executeCmdInternal(firstCmd, context);
      firstPromise = firstPromise || Promise.resolve([]);
      firstPromise.then(function (result) {
        var executePromise;

        if (!batch) {
          executePromise = Promise.all(result.map(function (a) {
            return context.wrappedDispatch(a);
          }));
        } else {
          executePromise = Promise.resolve();
        }

        executePromise.then(function () {
          var remainingSequence = list(cmds.slice(1), {
            batch: batch,
            sequence: true
          });
          var remainingPromise = executeCmdInternal(remainingSequence, context);

          if (remainingPromise) {
            remainingPromise.then(function (innerResult) {
              resolve(result.concat(innerResult));
            });
          } else {
            resolve(result);
          }
        });
      });
    }).then(flatten);
    return batch ? result : result.then(function () {
      return [];
    });
  }

  function handleDelayCmd(cmd, context) {
    var executeNestedCmd = function executeNestedCmd() {
      var cmdPromise = executeCmdInternal(cmd.nestedCmd, context);

      if (cmdPromise) {
        cmdPromise.then(function (actions) {
          actions.forEach(function (action) {
            return context.wrappedDispatch(action);
          });
        });
      }
    };

    var timerId;

    if (cmd.type === cmdTypes.SET_INTERVAL) {
      timerId = setInterval(executeNestedCmd, cmd.delayMs);
    } else {
      timerId = setTimeout(executeNestedCmd, cmd.delayMs);
    }

    if (cmd.scheduledActionCreator) {
      return Promise.resolve([cmd.scheduledActionCreator(timerId)]);
    } else {
      return null;
    }
  }

  function executeCmd(cmd, dispatch, getState) {
    var loopConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    return executeCmdInternal(cmd, {
      dispatch: dispatch,
      wrappedDispatch: dispatch,
      getState: getState,
      loopConfig: loopConfig
    });
  }

  function executeCmdInternal(cmd, context) {
    switch (cmd.type) {
      case cmdTypes.RUN:
        return handleRunCmd(cmd, context);

      case cmdTypes.ACTION:
        return Promise.resolve([cmd.actionToDispatch]);

      case cmdTypes.SET_TIMEOUT:
      case cmdTypes.SET_INTERVAL:
        return handleDelayCmd(cmd, context);

      case cmdTypes.LIST:
        return cmd.sequence ? handleSequenceList(cmd, context) : handleParallelList(cmd, context);

      case cmdTypes.MAP:
        {
          var possiblePromise = executeCmdInternal(cmd.nestedCmd, _objectSpread2(_objectSpread2({}, context), {}, {
            wrappedDispatch: function wrappedDispatch(action) {
              return context.wrappedDispatch(cmd.tagger.apply(cmd, _toConsumableArray(cmd.args).concat([action])));
            }
          }));

          if (!possiblePromise) {
            return null;
          }

          return possiblePromise.then(function (actions) {
            return actions.map(function (action) {
              return cmd.tagger.apply(cmd, _toConsumableArray(cmd.args).concat([action]));
            });
          });
        }

      case cmdTypes.NONE:
        return null;

      default:
        throw new Error("Invalid Cmd type ".concat(cmd.type));
    }
  }

  function simulateRun(_ref3) {
    var result = _ref3.result,
        success = _ref3.success;

    if (success && this.successActionCreator) {
      return this.successActionCreator(result);
    } else if (!success && this.failActionCreator) {
      return this.failActionCreator(result);
    }

    return null;
  }

  function run(func) {
    var _objectSpread2$1;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    {
      if (!options.testInvariants) {
        throwInvariant(typeof func === 'function', 'Cmd.run: first argument to Cmd.run must be a function');
        throwInvariant(_typeof(options) === 'object', 'Cmd.run: second argument to Cmd.run must be an options object');
        throwInvariant(!options.successActionCreator || typeof options.successActionCreator === 'function', 'Cmd.run: successActionCreator option must be a function if specified');
        throwInvariant(!options.failActionCreator || typeof options.failActionCreator === 'function', 'Cmd.run: failActionCreator option must be a function if specified');
        throwInvariant(!options.args || options.args.constructor === Array, 'Cmd.run: args option must be an array if specified');
      }
    }

    var testInvariants = options.testInvariants,
        rest = _objectWithoutProperties(options, ["testInvariants"]);

    return Object.freeze(_objectSpread2((_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, isCmdSymbol, true), _defineProperty(_objectSpread2$1, "type", cmdTypes.RUN), _defineProperty(_objectSpread2$1, "func", func), _defineProperty(_objectSpread2$1, "simulate", simulateRun), _objectSpread2$1), rest));
  }

  function simulateAction() {
    return this.actionToDispatch;
  }

  function action(actionToDispatch) {
    var _Object$freeze;

    {
      throwInvariant(_typeof(actionToDispatch) === 'object' && actionToDispatch !== null && typeof actionToDispatch.type !== 'undefined', 'Cmd.action: first argument and only argument to Cmd.action must be an action');
    }

    return Object.freeze((_Object$freeze = {}, _defineProperty(_Object$freeze, isCmdSymbol, true), _defineProperty(_Object$freeze, "type", cmdTypes.ACTION), _defineProperty(_Object$freeze, "actionToDispatch", actionToDispatch), _defineProperty(_Object$freeze, "simulate", simulateAction), _Object$freeze));
  }

  function clearTimeoutCmd(timerId) {
    return run(clearTimeout, {
      args: [timerId]
    });
  }

  function clearIntervalCmd(timerId) {
    return run(clearInterval, {
      args: [timerId]
    });
  }

  function setTimeoutCmd(nestedCmd, delayMs) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return delay(nestedCmd, delayMs, options, cmdTypes.SET_TIMEOUT, 'Cmd.setTimeout');
  }

  function setIntervalCmd(nestedCmd, delayMs) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return delay(nestedCmd, delayMs, options, cmdTypes.SET_INTERVAL, 'Cmd.setInterval');
  }

  function delay(nestedCmd, delayMs, options, cmdType, funcName) {
    var _Object$freeze2;

    {
      throwInvariant(isCmd(nestedCmd), "".concat(funcName, ": first argument must be another Cmd"));
      throwInvariant(typeof delayMs === 'number', "".concat(funcName, ": second argument must be a number"));
      throwInvariant(_typeof(options) === 'object', "".concat(funcName, ": third argument must be an options object"));
      throwInvariant(options.scheduledActionCreator === undefined || typeof options.scheduledActionCreator === 'function', "".concat(funcName, ": scheduledActionCreator option must be a function if specified"));
    }

    return Object.freeze((_Object$freeze2 = {}, _defineProperty(_Object$freeze2, isCmdSymbol, true), _defineProperty(_Object$freeze2, "type", cmdType), _defineProperty(_Object$freeze2, "nestedCmd", nestedCmd), _defineProperty(_Object$freeze2, "delayMs", delayMs), _defineProperty(_Object$freeze2, "scheduledActionCreator", options.scheduledActionCreator), _defineProperty(_Object$freeze2, "simulate", simulateDelay), _Object$freeze2));
  }

  function simulateDelay(timerId, nestedSimulation) {
    var result = this.nestedCmd.simulate(nestedSimulation);
    var nestedActions = null;

    if (Array.isArray(result)) {
      nestedActions = result;
    } else if (result) {
      nestedActions = [result];
    }

    if (this.scheduledActionCreator) {
      return [this.scheduledActionCreator(timerId)].concat(nestedActions);
    } else {
      return nestedActions;
    }
  }

  function simulateList(simulations) {
    return flatten(this.cmds.map(function (cmd, i) {
      return cmd.simulate(simulations[i]);
    }).filter(function (a) {
      return a;
    }));
  }

  function list(cmds) {
    var _objectSpread3;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    {
      if (!options.testInvariants) {
        throwInvariant(Array.isArray(cmds) && cmds.every(isCmd), 'Cmd.list: first argument to Cmd.list must be an array of other Cmds');
        throwInvariant(_typeof(options) === 'object', 'Cmd.list: second argument to Cmd.list must be an options object');
      }
    }

    var testInvariants = options.testInvariants,
        rest = _objectWithoutProperties(options, ["testInvariants"]);

    return Object.freeze(_objectSpread2((_objectSpread3 = {}, _defineProperty(_objectSpread3, isCmdSymbol, true), _defineProperty(_objectSpread3, "type", cmdTypes.LIST), _defineProperty(_objectSpread3, "cmds", cmds), _defineProperty(_objectSpread3, "simulate", simulateList), _objectSpread3), rest));
  }

  function simulateMap(simulation) {
    var _this = this;

    var result = this.nestedCmd.simulate(simulation);

    if (Array.isArray(result)) {
      return result.map(function (action) {
        return _this.tagger.apply(_this, _toConsumableArray(_this.args).concat([action]));
      });
    } else if (result) {
      return this.tagger.apply(this, _toConsumableArray(this.args).concat([result]));
    } else {
      return null;
    }
  }

  function map(nestedCmd, tagger) {
    var _Object$freeze3;

    {
      throwInvariant(isCmd(nestedCmd), 'Cmd.map: first argument to Cmd.map must be another Cmd');
      throwInvariant(typeof tagger === 'function', 'Cmd.map: second argument to Cmd.map must be a function that returns an action');
    }

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return Object.freeze((_Object$freeze3 = {}, _defineProperty(_Object$freeze3, isCmdSymbol, true), _defineProperty(_Object$freeze3, "type", cmdTypes.MAP), _defineProperty(_Object$freeze3, "tagger", tagger), _defineProperty(_Object$freeze3, "nestedCmd", nestedCmd), _defineProperty(_Object$freeze3, "args", args), _defineProperty(_Object$freeze3, "simulate", simulateMap), _Object$freeze3));
  }

  var none = Object.freeze((_Object$freeze4 = {}, _defineProperty(_Object$freeze4, isCmdSymbol, true), _defineProperty(_Object$freeze4, "type", cmdTypes.NONE), _defineProperty(_Object$freeze4, "simulate", function simulate() {
    return null;
  }), _Object$freeze4));
  var Cmd = {
    run: run,
    action: action,
    setTimeout: setTimeoutCmd,
    setInterval: setIntervalCmd,
    clearTimeout: clearTimeoutCmd,
    clearInterval: clearIntervalCmd,
    list: list,
    map: map,
    none: none,
    dispatch: dispatchSymbol,
    getState: getStateSymbol
  };

  var isLoop = function isLoop(array) {
    return Array.isArray(array) && array.length === 2 && isCmd(array[1]) && !isCmd(array[0]);
  };
  var getCmd = function getCmd(loop) {
    return isLoop(loop) ? loop[1] : null;
  };
  var getModel = function getModel(loop) {
    return isLoop(loop) ? loop[0] : loop;
  };
  var loop = function loop(model, cmd) {
    {
      throwInvariant(isCmd(cmd), 'Given cmd is not an Cmd instance.');
    }

    return [model, cmd];
  };
  var liftState = function liftState(state) {
    return isLoop(state) ? state : loop(state, Cmd.none);
  };

  var loopPromiseCaughtError = function loopPromiseCaughtError(originalActionType, error) {
    return "\nException thrown when running Cmds from action: ".concat(originalActionType, ".\n\nThrown exception: \n").concat(error, "\n");
  };

  var defaultLoopConfig = {
    DONT_LOG_ERRORS_ON_HANDLED_FAILURES: false,
    ENABLE_THUNK_MIGRATION: false
  };
  function install() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var loopConfig = Object.assign({}, defaultLoopConfig, config);
    return function (next) {
      return function (reducer, initialState, enhancer) {
        var _liftState = liftState(initialState),
            _liftState2 = _slicedToArray(_liftState, 2),
            initialModel = _liftState2[0],
            initialCmd = _liftState2[1];

        var cmdsQueue = [];

        var liftReducer = function liftReducer(reducer) {
          return function (state, action) {
            var result = reducer(state, action);

            var _liftState3 = liftState(result),
                _liftState4 = _slicedToArray(_liftState3, 2),
                model = _liftState4[0],
                cmd = _liftState4[1];

            cmdsQueue.push({
              originalAction: action,
              cmd: cmd
            });
            return model;
          };
        };

        var store = next(liftReducer(reducer), initialModel, enhancer);

        function runCmds(queue) {
          var promises = queue.map(runCmd).filter(function (x) {
            return x;
          });

          if (promises.length === 0) {
            return Promise.resolve();
          } else if (promises.length === 1) {
            return promises[0];
          } else {
            return Promise.all(promises).then(function () {});
          }
        }

        function runCmd(_ref) {
          var originalAction = _ref.originalAction,
              cmd = _ref.cmd;
          var cmdPromise = executeCmd(cmd, dispatch, store.getState, loopConfig);

          if (!cmdPromise) {
            return null;
          }

          return cmdPromise.then(function (actions) {
            if (!actions.length) {
              return;
            }

            return Promise.all(actions.map(dispatch));
          })["catch"](function (error) {
            console.error(loopPromiseCaughtError(originalAction.type, error));
            throw error;
          });
        }

        function dispatch(action) {
          if (loopConfig.ENABLE_THUNK_MIGRATION && typeof action === 'function') {
            return action(dispatch, store.getState);
          }

          var result = store.dispatch(action);
          var cmdsToRun = cmdsQueue;
          cmdsQueue = [];
          return runCmds(cmdsToRun).then(function () {
            return result;
          });
        }

        function replaceReducer(reducer) {
          return store.replaceReducer(liftReducer(reducer));
        }

        runCmd({
          originalAction: {
            type: '@@ReduxLoop/INIT'
          },
          cmd: initialCmd
        });
        return _objectSpread2(_objectSpread2({}, store), {}, {
          dispatch: dispatch,
          replaceReducer: replaceReducer
        });
      };
    };
  }

  function batchCmds(cmds) {
    switch (cmds.length) {
      case 0:
        return Cmd.none;

      case 1:
        return cmds[0];

      default:
        return Cmd.list(cmds);
    }
  }

  function combineReducers(childMap) {
    return function () {
      var rootState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var action = arguments.length > 1 ? arguments[1] : undefined;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      var cmds = [];
      var hasChanged = false;
      var newState = Object.keys(childMap).reduce(function (prev, key) {
        var childReducer = childMap[key];

        if (!childReducer) {
          if (!hasChanged) {
            prev = _objectSpread2({}, prev);
            hasChanged = true;
          }

          delete prev[key];
          return prev;
        }

        var currentChild = childReducer.apply(void 0, [prev[key], action].concat(args));

        if (isLoop(currentChild)) {
          cmds.push(getCmd(currentChild));
          currentChild = getModel(currentChild);
        }

        if (prev[key] !== currentChild && hasChanged) {
          prev[key] = currentChild;
        } else if (prev[key] !== currentChild) {
          prev = _objectSpread2(_objectSpread2({}, prev), {}, _defineProperty({}, key, currentChild));
          hasChanged = true;
        }

        return prev;
      }, rootState);
      return loop(newState, batchCmds(cmds));
    };
  }

  function mergeChildReducers() {
    console.warning('mergeChildReducers is deprecated. Use reduceReducers or combineReducers instead.');
    return DEPRECATED_mergeChildReducers.apply(void 0, arguments);
  } // eslint-disable-next-line camelcase

  function DEPRECATED_mergeChildReducers(parentResult, action, childMap) {
    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
      args[_key - 3] = arguments[_key];
    }

    var initialState = parentResult,
        parentCmd;

    if (isLoop(initialState)) {
      parentCmd = getCmd(initialState);
      initialState = getModel(initialState);
    }

    var cmds = parentCmd ? [parentCmd] : [];
    var hasChanged = false;
    var newState = Object.keys(childMap).reduce(function (prev, key) {
      var childReducer = childMap[key];

      if (!childReducer) {
        if (!hasChanged) {
          prev = _objectSpread2({}, prev);
          hasChanged = true;
        }

        delete prev[key];
        return prev;
      }

      var currentChild = childReducer.apply(void 0, [prev[key], action].concat(args));

      if (isLoop(currentChild)) {
        cmds.push(getCmd(currentChild));
        currentChild = getModel(currentChild);
      }

      if (prev[key] !== currentChild && hasChanged) {
        prev[key] = currentChild;
      } else if (prev[key] !== currentChild) {
        prev = _objectSpread2(_objectSpread2({}, prev), {}, _defineProperty({}, key, currentChild));
        hasChanged = true;
      }

      return prev;
    }, initialState);
    return loop(newState, batchCmds(cmds));
  }

  var r = (function () {
    for (var _len = arguments.length, reducers = new Array(_len), _key = 0; _key < _len; _key++) {
      reducers[_key] = arguments[_key];
    }

    return function (prevState, action) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      var _reducers$reduce = reducers.reduce(function (prevResult, reducer) {
        var result = reducer.apply(void 0, [prevResult.newState, action].concat(args));

        if (isLoop(result)) {
          return {
            newState: getModel(result),
            cmds: [].concat(_toConsumableArray(prevResult.cmds), [getCmd(result)])
          };
        }

        return {
          newState: result,
          cmds: prevResult.cmds
        };
      }, {
        newState: prevState,
        cmds: []
      }),
          newState = _reducers$reduce.newState,
          cmds = _reducers$reduce.cmds;

      return loop(newState, batchCmds(cmds));
    };
  });

  //should be unnecessary after https://github.com/rollup/rollup/issues/826

  function combineReducers$1() {
    return combineReducers.apply(void 0, arguments);
  } // eslint-disable-next-line camelcase

  function DEPRECATED_mergeChildReducers$1() {
    return DEPRECATED_mergeChildReducers.apply(void 0, arguments);
  }
  function mergeChildReducers$1() {
    return mergeChildReducers.apply(void 0, arguments);
  }
  function reduceReducers() {
    return r.apply(void 0, arguments);
  }

  exports.Cmd = Cmd;
  exports.DEPRECATED_mergeChildReducers = DEPRECATED_mergeChildReducers$1;
  exports.combineReducers = combineReducers$1;
  exports.getCmd = getCmd;
  exports.getModel = getModel;
  exports.install = install;
  exports.isLoop = isLoop;
  exports.liftState = liftState;
  exports.loop = loop;
  exports.mergeChildReducers = mergeChildReducers$1;
  exports.reduceReducers = reduceReducers;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
